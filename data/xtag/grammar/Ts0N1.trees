("s0N1" :COMMENT-DISPLAY? NIL :FEATURE-DISPLAY? NIL :EQUATION-DISPLAY? NIL :UNIFICATION-EQUATIONS "



S_r.b:<extracted> = -
S_r.b:<inv> = -
S_r.b:<assign-comp> = VP.t:<assign-comp>



S_r.b:<mode> = VP.t:<mode>
S_r.b:<mainv> = VP.t:<mainv>
S_r.b:<comp> = nil
S_r.b:<tense> = VP.t:<tense>
S_0:<assign-case> = S_r.b:<assign-case>
S_0.t:<mode> = ind/inf
S_0.t:<comp> = that/whether/for/nil
S_0.t:<assign-comp> = inf_nil
S_0.t:<inv> = -
S_0.t:<extracted> = -
S_r.b:<agr> = VP.t:<agr>
S_r.b:<passive> = VP.t:<passive>
VP.t:<passive> = -
VP.t:<agr pers> = 3
VP.b:<mode> = prep
VP.b:<assign-case> = acc
VP.b:<compar> = -
N:<agr> = NP_1.b:<agr>
NP_1.t:<wh> = -
NP_1.t:<case> = acc
NP_1.b:<case> = N.t:<case>
NP_1.b:<pron> = N.t:<pron>
NP_1.b:<compar> = N.t:<compar>
N.t:<compar> = -
N.t:<const> = NP_1.b:<const>
N.t:<gen> = NP_1.b:<gen>
N.t:<definite> = NP_1.b:<definite>
N.t:<quan> = NP_1.b:<quan>
N.t:<card> = NP_1.b:<card>
N.t:<decreas> = NP_1.b:<decreas>
" :COMMENTS "N predicative tree with sentential subject:
	For John to invest all of his money in worms is insanity.
	To love is pain.
	That the worms lived is tragedy.
" :SHAPE NIL :BORDER-WIDTH NIL :CONSTRAINT-STYLE NIL :CONNECTOR NIL :DEFAULT-STYLE NIL :SUBSCRIPT-STYLE NIL :WHITE-SPACE NIL  :MINIMUM-NODE-SEPARATION NIL :LEVEL-SEPARATION NIL)
 (((("S" . "r"))) (((("S" . "0")) :substp T))  (((("VP" . ""))) (((("V" . "")) :constraints "NA" :constraint-type :NA) (((("" . "v")))) )  (((("NP" . "1"))) (((("N" . "")) :headp T)) ) ) ) 
("W0s0N1" :COMMENT-DISPLAY? NIL :FEATURE-DISPLAY? NIL :EQUATION-DISPLAY? NIL :UNIFICATION-EQUATIONS "



S_q.b:<extracted> = +

S_q.b:<inv> = S_r.t:<inv>
S_r.t:<comp> = nil
S_r.b:<assign-comp> = inf_nil/ind_nil
S_r.b:<assign-comp> = VP.t:<assign-comp>




VP.t:<passive> = -
S_q.b:<wh> = NP_0.t:<wh>
S_q.b:<comp> = nil
S_q.b:<mode> = S_r.t:<mode>
S_r.b:<mode> = VP.t:<mode>
S_r.b:<comp> = nil
S_r.b:<tense> = VP.t:<tense>
S_r.b:<inv> = -
S_r.t:<case> = nom
NP_0:<trace> = S_0:<trace>
NP_0:<wh> = +
S_r.b:<agr> = VP.t:<agr>
S_r.b:<assign-case> = VP.t:<assign-case>
VP.b:<mode> = nom
VP.b:<assign-case> = acc
VP.b:<compar> = -
N:<agr> = NP_1.b:<agr>
NP_1.t:<wh> = -
NP_1.t:<case> = acc
NP_1.b:<case> = N.t:<case>
NP_1.b:<pron> = N.t:<pron>
NP_1.b:<compar> = N.t:<compar>
N.t:<compar> = -
N.t:<const> = NP_1.b:<const>
N.t:<gen> = NP_1.b:<gen>
N.t:<definite> = NP_1.b:<definite>
N.t:<quan> = NP_1.b:<quan>
N.t:<card> = NP_1.b:<card>
N.t:<decreas> = NP_1.b:<decreas>
S_r.t:<conj> = nil
" :COMMENTS "Predicative tree with sentential subject and mass noun predicatem,
subject extracted:
	What is insanity?

(Will also get W0nx0N1 parse.)
" :SHAPE NIL :BORDER-WIDTH NIL :CONSTRAINT-STYLE NIL :CONNECTOR NIL :DEFAULT-STYLE NIL :SUBSCRIPT-STYLE NIL :WHITE-SPACE NIL  :MINIMUM-NODE-SEPARATION NIL :LEVEL-SEPARATION NIL)
 (((("S" . "q"))) (((("NP" . "0")) :substp T))  (((("S" . "r"))) (((("S" . "0")) :constraints "NA" :constraint-type :NA) (((("" . "")))) )  (((("VP" . ""))) (((("V" . "")) :constraints "NA" :constraint-type :NA) (((("" . "v")))) )  (((("NP" . "1"))) (((("N" . "")) :headp T)) ) ) ) ) 
("Npxs0N1" :COMMENT-DISPLAY? NIL :FEATURE-DISPLAY? NIL :EQUATION-DISPLAY? NIL :UNIFICATION-EQUATIONS "
S_r.b:<extracted> = -
S_r.b:<inv> = -
S_r.b:<assign-comp> = VP.t:<assign-comp>



VP.b:<compar> = -
S_r.b:<mode> = VP.t:<mode>
S_r.b:<mainv> = VP.t:<mainv>
S_r.b:<comp> = nil
S_r.b:<tense> = VP.t:<tense>
S_0.t:<mode> = ind/inf
S_0.t:<comp> = that/whether/for/nil
S_0.t:<assign-comp> = inf_nil
S_0.t:<inv> = -
S_0.t:<extracted> = -
S_r.b:<agr> = VP.t:<agr>
S_r.b:<assign-case> = VP.t:<assign-case>
S_r.b:<passive> = VP.t:<passive>
VP.t:<passive> = -
VP.b:<mode> = prep
N:<agr> = NP_1.b:<agr>
NP_1.t:<wh> = -
NP_1.b:<case> = N.t:<case>
NP_1.b:<pron> = N.t:<pron>
NP_1.b:<wh> = N.t:<wh>
NP_1.b:<compar> = N.t:<compar>
N.t:<compar> = -
N.t:<const> = NP_1.b:<const>
N.t:<gen> = NP_1.b:<gen>
N.t:<definite> = NP_1.b:<definite>
N.t:<quan> = NP_1.b:<quan>
N.t:<card> = NP_1.b:<card>
N.t:<decreas> = NP_1.b:<decreas>
S_r.t:<inv> = -
PP_w.t:<wh> = +
NP_r.b:<wh> = NP_f.t:<wh>
NP_r.b:<agr> = NP_f.t:<agr>
NP_r.b:<case> = NP_f.t:<case>
NP_f.b:<case> = acc/nom
S_r.t:<comp> = nil
NP_r.b:<rel-clause> = +
NP_f.b:<case> = nom/acc
NP_r.b:<pron> = NP_f.t:<pron>

" :COMMENTS "N predicative tree with sentential subject:
	For John to invest all of his money in worms is insanity.
	To love is pain.
	That the worms lived is tragedy.
" :SHAPE NIL :BORDER-WIDTH NIL :CONSTRAINT-STYLE NIL :CONNECTOR NIL :DEFAULT-STYLE NIL :SUBSCRIPT-STYLE NIL :WHITE-SPACE NIL  :MINIMUM-NODE-SEPARATION NIL :LEVEL-SEPARATION NIL)
 (((("NP" . "r"))) (((("NP" . "f")) :footp T :constraints "NA" :constraint-type :NA))  (((("S" . "p")) :constraints "NA" :constraint-type :NA) (((("PP" . "w")) :substp T))  (((("S" . "r"))) (((("S" . "0")) :substp T))  (((("VP" . ""))) (((("V" . "")) :constraints "NA" :constraint-type :NA) (((("" . "v")))) )  (((("NP" . "1"))) (((("N" . "")) :headp T)) ) ) ) ) ) 
("Ncs0N1" :COMMENT-DISPLAY? NIL :FEATURE-DISPLAY? NIL :EQUATION-DISPLAY? NIL :UNIFICATION-EQUATIONS "
S_r.b:<extracted> = -
S_r.b:<inv> = -
S_r.b:<assign-comp> = VP.t:<assign-comp>



VP.b:<compar> = -
S_r.b:<mode> = VP.t:<mode>
S_r.b:<mainv> = VP.t:<mainv>
S_r.b:<comp> = nil
S_r.b:<tense> = VP.t:<tense>
S_0.t:<mode> = ind/inf
S_0.t:<comp> = that/whether/for/nil
S_0.t:<assign-comp> = inf_nil
S_0.t:<inv> = -
S_0.t:<extracted> = -
S_r.b:<agr> = VP.t:<agr>
S_r.b:<assign-case> = VP.t:<assign-case>
S_r.b:<passive> = VP.t:<passive>
VP.t:<passive> = -
VP.b:<mode> = prep
N:<agr> = NP_1.b:<agr>
NP_1.t:<wh> = -
NP_1.b:<case> = N.t:<case>
NP_1.b:<pron> = N.t:<pron>
NP_1.b:<wh> = N.t:<wh>
NP_1.b:<compar> = N.t:<compar>
N.t:<compar> = -
N.t:<const> = NP_1.b:<const>
N.t:<gen> = NP_1.b:<gen>
N.t:<definite> = NP_1.b:<definite>
N.t:<quan> = NP_1.b:<quan>
N.t:<card> = NP_1.b:<card>
N.t:<decreas> = NP_1.b:<decreas>
NP_r.b:<wh> = NP_f.t:<wh>
NP_r.b:<agr> = NP_f.t:<agr>
NP_r.b:<case> = NP_f.t:<case>
NP_f.b:<case> = acc/nom
S_r.t:<inv> = -
S_r.t:<mode> = ind/inf
S_r.t:<nocomp-mode> = ind
VP.t:<assign-comp> = that/for/ind_nil
S_r.b:<nocomp-mode> = S_r.b:<mode>
NP_r.b:<rel-clause> = +
NP_f.b:<case> = nom/acc
NP_r.b:<pron> = NP_f.t:<pron>

" :COMMENTS "N predicative tree with sentential subject:
	For John to invest all of his money in worms is insanity.
	To love is pain.
	That the worms lived is tragedy.
" :SHAPE NIL :BORDER-WIDTH NIL :CONSTRAINT-STYLE NIL :CONNECTOR NIL :DEFAULT-STYLE NIL :SUBSCRIPT-STYLE NIL :WHITE-SPACE NIL  :MINIMUM-NODE-SEPARATION NIL :LEVEL-SEPARATION NIL)
 (((("NP" . "r"))) (((("NP" . "f")) :footp T :constraints "NA" :constraint-type :NA))  (((("S" . "p")) :constraints "NA" :constraint-type :NA) (((("NP" . "w")) :constraints "NA" :constraint-type :NA) (((("" . "w")))) )  (((("S" . "r"))) (((("S" . "0")) :substp T))  (((("VP" . ""))) (((("V" . "")) :constraints "NA" :constraint-type :NA) (((("" . "v")))) )  (((("NP" . "1"))) (((("N" . "")) :headp T)) ) ) ) ) ) 
("N1s0" :COMMENT-DISPLAY? NIL :FEATURE-DISPLAY? NIL :EQUATION-DISPLAY? NIL :UNIFICATION-EQUATIONS "





S_r.b:<inv> = -
S_r.b:<comp> = nil
S_r.b:<extracted> = -
S_r.b:<agr> = VP.t:<agr>
S_r.b:<mode> = VP.t:<mode>
S_r.b:<mainv> = VP.t:<mainv>
S_r.b:<tense> = VP.t:<tense>
S_r.b:<assign-case> = VP.t:<assign-case>
S_r.b:<assign-comp> = VP.t:<assign-comp>

S_r.b:<passive> = VP.t:<passive>
VP.t:<passive> = -

NP_1.t:<wh> = -
NP_1.b:<agr> = N.t:<agr>
NP_1.b:<gen> = N.t:<gen>
NP_1.b:<case> = N.t:<case>
NP_1.b:<pron> = N.t:<pron>
NP_1.b:<quan> = N.t:<quan>
NP_1.b:<card> = N.t:<card>
NP_1.b:<const> = N.t:<const>
NP_1.b:<compar> = N.t:<compar>
NP_1.b:<decreas> = N.t:<decreas>
NP_1.b:<definite> = N.t:<definite>

N.t:<compar> = -

VP.b:<compar> = -
VP.b:<mode> = prep


S_0.t:<inv> = -
S_0.t:<extracted> = -
S_0.t:<mode> = ind/inf
S_0.t:<assign-comp> = inf_nil
S_0.t:<comp> = that/whether/for/nil
" :COMMENTS "N predicative tree with sentential subject:
	For John to invest all of his money in worms is insanity.
	To love is pain.
	That the worms lived is tragedy.
" :SHAPE NIL :BORDER-WIDTH NIL :CONSTRAINT-STYLE NIL :CONNECTOR NIL :DEFAULT-STYLE NIL :SUBSCRIPT-STYLE NIL :WHITE-SPACE NIL  :MINIMUM-NODE-SEPARATION NIL :LEVEL-SEPARATION NIL)
 (((("S" . "r"))) (((("NP" . "1"))) (((("N" . "")) :headp T)) )  (((("VP" . ""))) (((("V" . "")) :constraints "NA" :constraint-type :NA) (((("" . "v")))) )  (((("S" . "0")) :substp T)) ) ) 
