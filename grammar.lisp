(in-package #:nlp)

(defun add-rule (sym rule table)
  "Add a grammar rule to the table"
  (if (gethash sym table)
      (pushnew rule (gethash sym table) :test 'equalp)
      (setf (gethash sym table) (list rule))))

(defun terminal-p (sym)
  "Is symbol a terminal in our grammar?"
  (hash-table-p (gethash sym (pos-cfg *pos-db*))))

(defun non-terminal-p (sym)
  "Is symbol a non-terminal in our grammar?"
  (null (hash-table-p (gethash sym (pos-cfg *pos-db*)))))

(defun syntax-leaves (tree)
  "Extract the POS leaves from a parsed tree"
  (let ((sentence nil))
    (labels ((walk (tree)
               (cond ((null tree)
                      nil)
                     ((and (consp tree)
                           (atom (first tree))
                           (not (eql '-NONE- (first tree)))
                           (atom (second tree)))
                      (push (second tree) sentence))
                     ((consp tree)
                      (dolist (subtree tree)
                        (walk subtree))))))
      (walk tree)
      (mapcar (lambda (w)
                (if (numberp w)
                    (format nil "~D" w)
                    (symbol-name w)))
              (reverse sentence)))))

(defun extract-parsed-sentences (file)
  "Extract all sentences from a parsed corpus"
  (map-parsed-corpus 'syntax-leaves file :collect? t))

(defun extract-sentence-grammar (tree)
  "Derive grammar rules form a parse tree"
  (let ((grammar (make-hash-table)) (start-symbol (first tree)))
    (labels
        ((walk (tree)
           (cond ((null tree)
                  nil)
                 ((and (consp tree)
                       (atom (first tree))
                       (not (eql '-NONE- (first tree)))
                       (consp (second tree)))
                  (let ((children nil))
                    (dolist (child (rest tree))
                      (push (first child) children)
                      (walk child))
                    (if (gethash (first tree) grammar)
                        (pushnew (reverse children)
                                 (gethash (first tree) grammar)
                                 :test 'equalp)
                        (setf (gethash (first tree) grammar)
                              (list (reverse children))))))
                 ((and (consp tree)
                       (atom (first tree))
                       (not (eql '-NONE- (first tree)))
                       (atom (second tree)))
                  (when (numberp (second tree))
                    (setf (second tree)
                          (intern (format nil "~D" (second tree)))))
                  (if (gethash (first tree) grammar)
                      (pushnew (symbol-name (second tree))
                               (gethash (first tree) grammar)
                               :test 'equalp)
                      (setf (gethash (first tree) grammar)
                            (list (symbol-name (second tree))))))
                 ((consp tree)
                  (dolist (subtree tree)
                    (walk subtree))))))
      (walk tree)
      (values grammar start-symbol))))

(defun merge-rules (key value table)
  "Merge rules in a grammar table"
  (setf (gethash key table)
        (remove-duplicates (append value (gethash key table))
                           :test 'equalp)))

(defun strip-function-tags (tag)
  "Strip the Penn Treebank Function Tag parts"
  (intern (cl-ppcre:regex-replace "((\\-|\\=)[^\\-]+){1,}$"
                                  (if (symbolp tag)
                                      (symbol-name tag)
                                      tag)
                                  "")))

(defun massage-rhs (rhs)
  "Remove various unwanted tags from the rule."
  (remove-if 'null
             (mapcar
              (lambda (p)
                (cond ((listp p) (massage-rhs p))
                      ((eql p '-NONE-) nil)
                      ((or (eql p '-LRB-) (eql p '-LCB-)) '|(|)
                      ((or (eql p '-RRB-) (eql p '-RCB-)) '|)|)
                      (t (strip-function-tags p))))
              rhs)))

(defun extract-grammar-rules (file &optional pos-db)
  "Derive a grammar from the parsed corpus FILE"
  (let ((rules (make-hash-table))
        (s-count (make-hash-table))
        (p-count (make-hash-table :test 'equalp))
        (probabilities (make-hash-table))
        (index (make-hash-table)))
    (map-parsed-corpus
     (lambda (tree)
       (multiple-value-bind (grammar start)
           (extract-sentence-grammar tree)
         (setq start (strip-function-tags start))
         (when (eq start 'S)
           (add-rule :start start rules)
           (init-or-increment s-count :start)
           (init-or-increment p-count (cons :start start))
           (maphash
            (lambda (lhs rhs)
              (setq lhs (strip-function-tags lhs))
              (setq rhs (massage-rhs rhs))
              (dolist (p rhs)
                (init-or-increment s-count lhs)
                (init-or-increment p-count (cons lhs p)))
              (if (gethash lhs rules)
                  (dolist (i rhs)
                    (setf (gethash lhs rules)
                          (pushnew i (gethash lhs rules)
                                   :test 'equalp)))
                  (setf (gethash lhs rules) rhs)))
            grammar))))
     file :collect? nil)
    (maphash (lambda (lhs rhs)
               (unless (or (eql lhs :start) (every 'listp rhs))
                 (let ((words (make-hash-table :test 'equal)))
                   (dolist (word rhs)
                     (let ((word (format nil "~A" word)))
                       (setf (gethash word words) t)
                       (when (pos-db? pos-db)
                         (add-to-lexicon word lhs pos-db))))
                   (setf (gethash lhs rules) words))))
             rules)
    (maphash (lambda (form count)
               (destructuring-bind (lhs &rest rhs) form
                 (unless (hash-table-p (gethash lhs probabilities))
                   (setf (gethash lhs probabilities)
                         (make-hash-table :test 'equalp)))
                 (setf (gethash rhs (gethash lhs probabilities))
                       (/ count (gethash lhs s-count)))))
             p-count)
    (maphash (lambda (lhs rhs)
               (if (listp rhs)
                   (dolist (p rhs)
                     (if (listp p)
                         (add-rule (first p) lhs index)
                         (add-rule p lhs index)))
                   (add-rule rhs lhs index)))
             rules)
    (if (pos-db? pos-db)
        (values (setf (pos-cfg pos-db) rules)
                (setf (pos-pcfg pos-db) probabilities)
                (setf (pos-cfg-idx pos-db) index))
        (values rules probabilities index))))

(defun load-cfg (file &optional pos-db)
  "Load a CFG from a file"
  (let ((rules (make-hash-table))
        (index (make-hash-table)))
    (add-rule :start '(S) rules)
    (with-open-file (in file)
      (do ((line (read-line in nil nil) (read-line in nil nil)))
          ((null line))
        (when (> (length line) 1)
          (destructuring-bind (lhs rhs) (split "\\s*->\\s*" line)
            (let ((lhs (intern lhs))
                  (rhs (mapcar 'intern (split "\\s+" rhs))))
              (add-rule lhs rhs rules))))))
    (maphash (lambda (lhs rhs)
               (if (listp rhs)
                   (dolist (p rhs)
                     (if (listp p)
                         (add-rule (first p) lhs index)
                         (add-rule p lhs index)))
                   (add-rule rhs lhs index)))
             rules)
    (if (pos-db? pos-db)
        (values (setf (pos-cfg pos-db) rules)
                (setf (pos-cfg-idx pos-db) index))
        (values rules index))))

(defun load-pcfg (file &optional pos-db)
  "Load a PCFG from FILE"
  (let ((rules (make-hash-table))
        (probabilities (make-hash-table))
        (index (make-hash-table)))
    (add-rule :start '(S) rules)
    (setf (gethash :start probabilities) (make-hash-table :test 'equalp))
    (setf (gethash '(S) (gethash :start probabilities)) 1)
    (with-open-file (in file)
      (do ((line (read-line in nil nil) (read-line in nil nil)))
          ((null line))
        (when (> (length line) 1)
          (register-groups-bind (lhs p rhs)
              ("^([a-zA-Z0-9]+)\\s+\\(([0-9.]+)\\)\\s+\\-\\>\\s+(.*)$" line)
            (let ((lhs (intern lhs))
                  (p (parse-number p))
                  (rhs (mapcar 'intern (split "\\s+" rhs))))
              ;;(format t "READ: '~A' ('~F') -> '~A'~%" lhs p rhs)
              (unless (hash-table-p (gethash lhs probabilities))
                (setf (gethash lhs probabilities) (make-hash-table :test 'equalp)))
              (setf (gethash rhs (gethash lhs probabilities)) p)
              (add-rule lhs rhs rules))))))
    (maphash (lambda (lhs rhs)
               (if (listp rhs)
                   (dolist (p rhs)
                     (if (listp p)
                         (add-rule (first p) lhs index)
                         (add-rule p lhs index)))
                   (add-rule rhs lhs index)))
             rules)
    (if (pos-db? pos-db)
        (values (setf (pos-cfg pos-db) rules)
                (setf (pos-cfg-idx pos-db) index)
                (setf (pos-pcfg pos-db) probabilities))
        (values rules index probabilities))))

(defun describe-pcfg (&key (stream t) pcfg)
  (maphash (lambda (s table)
             (let ((productions
                    (loop
                       for production being the hash-keys in table
                       using (hash-value p)
                       collecting (cons p production))))
               (dolist (pair (sort productions '> :key 'car))
                 (format stream "~A (~F) -> ~{~A~^ ~}~%"
                         s (car pair) (cdr pair)))))
           (or pcfg (pos-pcfg *pos-db*))))

(defun describe-grammar (&optional grammar)
  (maphash (lambda (lhs rhs)
             (format t "~A -> " lhs)
             (if (hash-table-p rhs)
                 (format t "TERMINAL (~D words)~%"
                         (hash-table-count rhs))
                 (format t "~A~%" rhs)))
           (or grammar (pos-cfg *pos-db*))))

(defun lookup-pos-productions (pos)
  "Expand POS"
  (let ((p (gethash pos (pos-cfg-idx *pos-db*))))
    (if (listp p)
        p
        (list p))))

(defun make-cnf-grammar (grammar &optional pos-db)
  "Convert a grammar to Chomsky Normal Form"
  (let* ((cnf-grammar (make-hash-table))
         (cnf-index (make-hash-table :test 'equalp))
         (subs-map (make-hash-table :test 'equalp))
         (subs-rev (make-hash-table :test 'equalp))
         (unit-rules nil)
         (symbols (loop
                     for k being the hash-keys in grammar
                     collecting k))
         (terminals (remove-if-not 'terminal-p symbols))
         (non-terminals (remove-if-not 'non-terminal-p symbols)))
    (dolist (s terminals)
      (setf (gethash s cnf-grammar) :see-lexicon))
    (format t "Finished with terminals~%")
    (dolist (s non-terminals)
      (unless (eq s :start)
        (dolist (p (gethash s grammar))
          (let ((len (length p)))
            (cond ((or (= 2 len)
                       (and (= 1 len) (every 'terminal-p p)))
                   (add-rule s p cnf-grammar))
                  ((> len 2)
                   (let ((sym s) (new-sym (gensym "CNF")))
                     (loop for i from 0 to (- len 3) do
                          (let ((new-r `(,(nth i p) ,new-sym)))
                            (add-rule sym new-r cnf-grammar)
                            (add-rule sym new-r subs-map)
                            (add-rule new-r sym subs-rev))
                          (setq sym new-sym
                                new-sym (gensym "CNF")))
                     (let ((new-r `(,(nth (- len 2) p)
                                     ,(nth (- len 1) p))))
                       (add-rule sym new-r cnf-grammar)
                       (add-rule sym new-r subs-map)
                       (add-rule new-r sym subs-rev))))
                  ((= len 1)
                   (pushnew (list s p) unit-rules :test 'equalp))
                  (t
                   (format t "CNF: Strange case: ~A -> ~A~%"
                           s p)))))))
    (format t "Finished with non-terminals~%")
    (dolist (rule unit-rules)
      (unless (member '-NONE- rule)
        (let ((s (first rule)) (p (first (second rule))))
          ;;(format t "Fixing unit rule ~A -> ~A~%" s p)
          (let ((rules (gethash p cnf-grammar)))
            (dolist (p1 rules)
              (pushnew p1 (gethash s cnf-grammar) :test 'equalp))))))
    (format t "Finished with unit rules~%")
    (maphash (lambda (lhs rhs)
               (when (listp rhs)
                 (handler-case
                     (dolist (p rhs)
                       (add-rule (first p) lhs cnf-index))
                   (error (c)
                     (declare (ignore c))
                     (format t "Cannot index ~A -> ~A~%"
                             lhs rhs)))))
             cnf-grammar)
    ;; Add start symbol
    (setf (gethash :start cnf-grammar) (gethash :start grammar))
    (if (pos-db? pos-db)
        (values (setf (pos-cnf-grammar pos-db) cnf-grammar)
                (setf (pos-cnf-index pos-db) cnf-index)
                (setf (pos-cnf-subs-map pos-db) subs-map)
                (setf (pos-cnf-subs-rev pos-db) subs-rev))
        (values cnf-grammar cnf-index subs-map subs-rev))))

(defun cnf-rev-lookup (pair)
  (gethash pair (pos-cnf-index *pos-db*)))

(defun cnf-lookup (sym)
  (gethash sym (pos-cnf-grammar *pos-db*)))

(defun cnf-grammar-size (&optional (pos-db *pos-db*))
  (hash-table-count (pos-cnf-grammar pos-db)))
