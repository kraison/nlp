(in-package #:nlp)

(defun print-lex-sym (ls stream d)
  (declare (ignore d))
  (format stream "#<LEX-SYM: ~A(~A,~A,~F)>"
          (sym ls) (word ls) (pos ls) (p ls)))

(defstruct (lex-sym
             (:conc-name nil)
             (:print-function print-lex-sym))
  sym word pos p)

(defmethod lex-sym-equal ((s1 lex-sym) (s2 lex-sym))
  (and (eq (sym s1) (sym s2))
       (equal (word s1) (word s2))
       (eq (pos s1) (pos s2))))

(defun sxhash-ls (ls)
  (sxhash (list (sym ls) (word ls) (pos ls))))

(sb-ext:define-hash-table-test lex-sym-equal sxhash-ls)

(defun make-lcfg-table (&key synchronized)
  (make-hash-table :test 'lex-sym-equal :synchronized synchronized))

(defun extract-sentence-lgrammar (tree)
  (let ((grammar (make-lcfg-table)) (start-symbol (first tree)))
    (labels
        ((walk (tree)
           (cond ((null tree) nil)
                 ((and (consp tree)
                       (atom (first tree))
                       (not (eql '-NONE- (first tree)))
                       (consp (second tree)))
                  (let ((children nil))
                    (dolist (child (rest tree))
                      (push (first child) children)
                      (walk child))
                    (if (gethash (first tree) grammar)
                        (pushnew (reverse children)
                                 (gethash (first tree) grammar)
                                 :test 'equalp)
                        (setf (gethash (first tree) grammar)
                              (list (reverse children))))))
                 ((and (consp tree)
                       (atom (first tree))
                       (not (eql '-NONE- (first tree)))
                       (atom (second tree)))
                  (when (numberp (second tree))
                    (setf (second tree)
                          (intern (format nil "~D" (second tree)))))
                  (let ((sym (make-lex-sym :sym (first tree)
                                           :word (second tree)
                                           :pos (first tree))))
                    (if (gethash sym grammar)
                        (pushnew (symbol-name (second tree))
                                 (gethash (first tree) grammar)
                                 :test 'equalp)
                        (setf (gethash (first tree) grammar)
                              (list (symbol-name (second tree))))))
                  ((consp tree)
                   (dolist (subtree tree)
                     (walk subtree))))))
         (walk tree)
         (values grammar start-symbol)))))
